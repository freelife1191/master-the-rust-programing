# Generics

- 제네릭을 사용하면 특정 유형에 얽매이지 않고 특정 요구 사항을 충족하는 모든 유형에서 작동할 수 있는 함수나 유형을 작성할 수 있습니다
- 다양한 데이터 유형과 함께 사용할 수 있는 코드를 작성할 수 있으므로 코드를 더 재사용 가능하고 유연하게 만듭니다

### 언어의 많은 구성이 Generics를 활용할 수 있다

1. Functions
2. Structs
3. Enums
4. Traits
5. Function and closure as arguments
6. Methods

```rust
fn find_max_int(v: &[i32]) -> Option<i32> {
    if v.is_empty() {
        return None;
    }

    let mut max = v[0];
    for &n in v {
        if n > max {
            max = n;
        }
    }

    Some(max)
}
```

## 단일화

- Rust에서 제네릭을 사용해도 심각한 성능 오버헤드가 발생하지 않습니다. Rust의 제네릭은 단일형화를 사용하여 구현됩니다. 즉, 컴파일러는 제네릭 함수나 유형과 함께 사용되는 각 구체적인 유형에 대해 별도의 코드를 생성합니다
- 이로 인해 컴파일된 코드의 바이너리 크기가 증가할 수 있지만 코드가 사용되는 특정 유형에 특화되어 있기 때문에 실행 속도도 빨라집니다

> 런타임 오버헤드 없이 해당 유형에 맞게 특별히 작성된 것처럼 컴파일러에 의해 최적화되는 코드입니다


## Summary: function_name<T>

- 함수 이름 뒤의 `<T>`는 '제네릭 유형 매개변수 구문'입니다
- `<T>`는 함수가 일반 함수이고 모든 유형을 허용할 수 있음을 지정하는 데 필요합니다. 이것이 없으면 컴파일러는 매개변수 측의 `T`를 일반 유형 매개변수 대신 특정 유형으로 해석합니다
- `find_max([1, 2, 3])`로 함수를 호출하면 `T`는 `i32`로 추론됩니다. 마찬가지로 `find_max(&["apple", "banana", "cherry"])`로 함수를 호출하면 `T`는 `&str`로 추론됩니다
- 'T' 대신 유효한 식별자를 유형 매개변수로 사용할 수 있습니다. 그러나 Rust에서는 유형 매개변수를 표시하기 위해 `T`, `U`, `V` 등과 같은 단일 대문자를 사용하는 것이 일반적인 관행입니다